/*
 * This code is automatically generated by MAG
 * Copyright (C) 2014 Chan Ngo, INRIA
 * chan.ngo@inria.fr
 */


/*
 * User's includes to cc file
 */

#include "consumer.h"
#include "producer.h"
#include "monitor.h"

/*
 * Monitor's formula:
 */

//	 PBLTL forumula: G <= #2000 ((c_read = 38) => (F <= #14 (c_read = 64))) 
//	 clock(s): 
//			MON_TIMED_NOTIFY_PHASE_END
//


/*
 * Constructor
 */

monitor0::monitor0(sc_core::mon_observer* obs, Consumer* obj0, Producer* obj1) : sc_core::mon_prototype() {

  // Observer
  observer = obs;
  // Usertypes
  pnt_con = obj0;
  pnt_pro = obj1;
  // Locations
  // Plocations
  // Value callbacks
  // Attributes - nothing to initialization
  // Event clocks
  // Register with observer
  observer->register_monitor(this, MON_TIMED_NOTIFY_PHASE_END);
}

/*
 * Destructor
 */

monitor0::~monitor0() {

}

/*
 * Simulate a step of the monitor.
 */

void
monitor0::step() {
  //Get command from standard input - stdin
  std::string cmd;

  while (true) {
    std::getline(std::cin, cmd);
    // Get quit command
    if (strcmp(cmd.c_str(), "#plasma-quit#") == 0) {
      sc_stop();
      std::cout << "\n# plasma-quit at " << sc_time_stamp() << " #\n" << std::endl;
      exit (0);
    }

    // Get an invalid command
    else if (strcmp(cmd.c_str(), "#plasma-newstate#") != 0) {
      // Wait for a valid command
      continue;
    }

    // Get a new state request
    else {
      // Process the command
      break;
    }
  }

  std::stringstream outputstate;
  outputstate.str ();
  outputstate << "\n# plasma-state [ (";


  // Log attributes values
  outputstate << "c_read";
  outputstate << " : ";
  outputstate << pnt_con->c_int;
  outputstate << ", ";

  outputstate << "c_write";
  outputstate << " : ";
  outputstate << pnt_pro->c_int;



  // Log event clocks - Boolean


  // Log locations - Boolean


  // Log pattern locations - plocation - Boolean


  // Log callback values

  // Send the logged state to stdout
  outputstate << ")" << " : ";
  outputstate << sc_time_stamp() ;
  outputstate << " ] #\n" << std::endl;
  std::cout << outputstate.str();
}


void
monitor0::callback_timed_notify_phase_end() {
 step();
}

// static instance variable
local_observer* local_observer::m_instance;



/*
 * Constructor
 */
local_observer::local_observer(unsigned int verbosity, Consumer* pnt_con, Producer* pnt_pro) : sc_core::mon_observer(verbosity) {

  monitor0* monitor0_inst = new monitor0(this, pnt_con, pnt_pro);
  mons.push_back(monitor0_inst);

}

/*
 * Destructor
 */
local_observer::~local_observer() {

  if (m_instance)
    delete m_instance;

}

/*
 * Create instance
 */
local_observer* local_observer::createInstance(unsigned int verbosity, Consumer* pnt_con, Producer* pnt_pro) {

  if (m_instance == NULL) {
    m_instance = new local_observer(verbosity, pnt_con, pnt_pro);  }

  return m_instance;

}

/*
 * Get instance
 */
local_observer* local_observer::getInstance() {

  return m_instance;

}
