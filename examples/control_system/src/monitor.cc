/*
 * This code is automatically generated by MAG
 * Copyright (C) 2014 Chan Ngo, INRIA
 * chan.ngo@inria.fr
 */


/*
 * User's includes to cc file
 */

#include "bus.h"
#include "clk_tick.h"
#include "proci.h"
#include "procm.h"
#include "proco.h"
#include "sa_grp.h"
#include "monitor.h"

/*
 * Monitor's formula:
 */

//	 PBLTL forumula: F <= #14400 (proci_status = 2 & number_sensors < 37) 
//	 clock(s): 
//			tick_notified
//


/*
 * Constructor
 */

monitor0::monitor0(sc_core::mon_observer* obs, Clk_tick* obj0, Proci* obj1, Procm* obj2, Proco* obj3, Sa_grp* obj4) : sc_core::mon_prototype() {

  // Observer
  observer = obs;
  // Usertypes
  pnt_clktick = obj0;
  pnt_proci = obj1;
  pnt_procm = obj2;
  pnt_proco = obj3;
  pnt_sa = obj4;
  // Locations
  // Plocations
  // Value callbacks
  // Attributes - nothing to initialization
  // Event clocks
  tick_notified = false;
  // Register with observer
  observer->register_monitor(this, &(pnt_clktick->e_tick));
}

/*
 * Destructor
 */

monitor0::~monitor0() {

}

/*
 * Simulate a step of the monitor.
 */

void
monitor0::step() {
  //Get command from standard input - stdin
  std::string cmd;

  while (true) {
    std::getline(std::cin, cmd);
    // Get quit command
    if (strcmp(cmd.c_str(), "#plasma-quit#") == 0) {
      sc_stop();
      std::cout << "\n# plasma-quit at " << sc_time_stamp() << " #\n" << std::endl;
      exit (0);
    }

    // Get an invalid command
    else if (strcmp(cmd.c_str(), "#plasma-newstate#") != 0) {
      // Wait for a valid command
      continue;
    }

    // Get a new state request
    else {
      // Process the command
      break;
    }
  }

  std::stringstream outputstate;
  outputstate.str ();
  outputstate << "\n# plasma-state [ (";


  // Log attributes values
  outputstate << "number_actuators";
  outputstate << " : ";
  outputstate << pnt_sa->actuators;
  outputstate << ", ";

  outputstate << "number_sensors";
  outputstate << " : ";
  outputstate << pnt_sa->sensors;
  outputstate << ", ";

  outputstate << "proci_reboot_number";
  outputstate << " : ";
  outputstate << pnt_proci->number_reboot;
  outputstate << ", ";

  outputstate << "proci_status";
  outputstate << " : ";
  outputstate << pnt_proci->proci_status;
  outputstate << ", ";

  outputstate << "procm_status";
  outputstate << " : ";
  outputstate << pnt_procm->procm_status;
  outputstate << ", ";

  outputstate << "proco_reboot_number";
  outputstate << " : ";
  outputstate << pnt_proco->number_reboot;
  outputstate << ", ";

  outputstate << "proco_status";
  outputstate << " : ";
  outputstate << pnt_proco->proco_status;
  outputstate << ", ";

  outputstate << "timeout_counts";
  outputstate << " : ";
  outputstate << pnt_procm->count;



  // Log event clocks - Boolean
  outputstate << ", ";
  if (tick_notified) {
    outputstate << "tick_notified";
    outputstate << " : ";
    outputstate << "true";
  }
  else {
    outputstate << "tick_notified";
    outputstate << " : ";
    outputstate << "false";
  }


  // Log locations - Boolean


  // Log pattern locations - plocation - Boolean


  // Log callback values

  // Send the logged state to stdout
  outputstate << ")" << " : ";
  outputstate << sc_time_stamp() ;
  outputstate << " ] #\n" << std::endl;
  std::cout << outputstate.str();
}


void
monitor0::callback_event_notified(sc_core::sc_event* event) {
  if (event == &(pnt_clktick->e_tick)) {
    tick_notified = true;
  }

  step();

  if (event == &(pnt_clktick->e_tick)) {
    tick_notified = false;
  }

}

// static instance variable
local_observer* local_observer::m_instance;



/*
 * Constructor
 */
local_observer::local_observer(unsigned int verbosity, Clk_tick* pnt_clktick, Proci* pnt_proci, Procm* pnt_procm, Proco* pnt_proco, Sa_grp* pnt_sa) : sc_core::mon_observer(verbosity) {

  monitor0* monitor0_inst = new monitor0(this, pnt_clktick, pnt_proci, pnt_procm, pnt_proco, pnt_sa);
  mons.push_back(monitor0_inst);

}

/*
 * Destructor
 */
local_observer::~local_observer() {

  if (m_instance)
    delete m_instance;

}

/*
 * Create instance
 */
local_observer* local_observer::createInstance(unsigned int verbosity, Clk_tick* pnt_clktick, Proci* pnt_proci, Procm* pnt_procm, Proco* pnt_proco, Sa_grp* pnt_sa) {

  if (m_instance == NULL) {
    m_instance = new local_observer(verbosity, pnt_clktick, pnt_proci, pnt_procm, pnt_proco, pnt_sa);  }

  return m_instance;

}

/*
 * Get instance
 */
local_observer* local_observer::getInstance() {

  return m_instance;

}
